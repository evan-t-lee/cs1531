# Teamwork

## Team Meetings
In accordance with our initial plan from iteration 1, the project was modulated into four main phases. In each phase it was expected that members complete a certain task within the timeframe provided. To ensure everyone was on the same page, reminding members of deadlines and expectations, there were two meetings each week. The first meeting of the week was an asynchronous group discussion, the expectation was to update the group towards the beginning of the week. To facilitate this, these meetings were not in person and over online messaging apps. The second meeting of the week was a stand-up/ meeting when we were all there for the lab. The purpose of this meeting was to clarify coding details, discuss data structures and ensure members were on track to complete their targets. Having bi-weekly checkpoints throughout the week was a large driving factor to having more than three quarters of our code written a week before iteration two was due.  We plan to maintain this schedule as the benefits are substantial.  

### TimeTable
|Date    | Discussion                                                                                 |
|:------:|--------------------------------------------------------------------------------------------|
|12 Oct  | Protocols were established, examples shown and mistakes corrected                          |
|17 Oct  | Corrected the efficiency of code and decided to remove classes                             |
|20 Oct  | Reviewed skeleton code, discussed front end integration and established the data structures|
|24 Oct  | Finalised data access methods, ironed out details concerning return specifications         |
|26 Oct  | Reviewed where all members are up to in the code                                           |

## How meetings were run
Throughout the past two weeks we ensured that every member had a responsibility for sections; split up into auth, channels, message and user functions. For each of our meetings, each member updated the group of where they were and what they needed help with, this was the extent of the issues covered in our meetings. The set agenda ensured that there were always predefined items to discuss and a definite end to the discussion, this was effective as the meetings were hardly dragged out or ran overtime.  

## Major outcomes of meeting
### Impact of meeting scheduling
A major outcome of our meetings was the consensus of data structures. Data storage specifications and methods were released a week before the due date. This ambiguity led to a great deal of confusion before our meeting in person. Due to our agile approach to the project, it became apparent that it wasn?t just the outputs that had to be specified. Any changes on the global data structures had to be agreed upon or pre-set. A large proportion of the code that was written prior to this meeting had to be rewritten. While the members responsible for sections like ?messages? had complete autonomy over the data structures, sections like channels and auth were interrelated and some degree of pair programming was required.  Despite the spacing of meetings every 4 or so days, the data structures were not completely established which caused a conflict in storage methods across the interrelated functions.    

### Conflict resolution : Need for optimisation
In the case of discrepancies on decisions, members of the group would vote for a decision, voting for person A, B or without preference. In the case of a tie breaker, each member would present their case until the issue is resolved. While the conflict resolution method was effective, the method would take a lot of time which meant the meeting agenda was not completely covered. Urgent items that were not covered overflowed into an instant messaging group chat. By improving our conflict resolution method, overflows are less likely to occur improving the efficiency of the group. As such our goal for the next iteration is to improve our method of conflict resolution. 

### Handling specification changes 
Due to the agile nature of the project wherein, the specifications are constantly being updated due to the constant communication between programmers and stakeholders, the iteration could not be completed in its entirety on the days that were planned in iteration one.  While the expectation was to have a complete project the Friday before the due date, this simply was not possible as the group had to wait for the specifications to be released. This had ramifications on other sections of the project such as ensuring the coverage of the test and the documentation of the project which was compiled at the last minute.  Despite these issues, a large proportion of the project was complete due to the phases outlined on our task board. 

### Phases
These phases provided focus for the whole group, to ensure that basics functions such as create channel and channel invites, were written before functions such as standup. While none of the code was functional, the early start provided a skeleton or general structure which reduced the workload later in the iteration in addition to providing an example which conceptually harder functions could be based on. The issues presented by the staggered release of specifications was also mitigated due to the open communication between members.  Even when meetings weren?t scheduled, once the specifications were released, a member of the group would update the group chat which would ensure all members had some idea of the changes before the next meeting. Inevitably, the changes in schedule meant that the expectations for turnover had to be tightened. While some members were not able to meet these requirements due to commitments outside of COMP1531, it provided a sense of urgency much earlier in project which encouraged consistent output over the iteration.   

### Issues with sections
Having the functions sectioned off by categories: auth, channels, messages, users and miscellaneous, as is described on our task board also came with its own issues. Our group took no measure to assess how difficult each function would be and gave responsibility arbitrarily. This created a non-balanced distribution of workload between group members which came up often in our group discussions.  The imbalances generally issued from the necessary complexity of the function, the need to learn difficult python functions in relation to timestamps and unclear specifications. The task board provided a great deal of flexibility within the distribution of work, if one section was identified to be quite hard then the harder function could be exchanged for a straightforward function. The reassignment of functions throughout the iteration mitigated the unbalanced workloads. Another strategy that was implemented was conducting code reviews and/or pair programming during scheduled meetings. 

### Issues with frontend integration
Despite the frontend integration not being the focus for this iteration, the integration was started before the iteration update.  This implementation of this section was originally key to the groups testing of the functions, our intention was to manually test the program through flask in addition to the written test, hence the early start to the front-end integration. Initially request.form.get() wouldn't work due to errors in the frontend. To overcome this request.get_json() was used instead. A couple days later request.get_json() no longer worked but request.form.get() finally worked. Even now, GET requests passed from frontend to backend don't properly work (and data fields such as 'token' are evaluated as 'None'), making it impossible to test the interface as was initially intended.  Even though pylint is not a useful quantification of how successful the project is, we have reverted to using it as a basis of the quality of the coverage of our testing and in turn the quality of our code. This does assume that the code meets the requirements of the specifications and that the tests cover all possibilities but without a method to conduct white box testing, this is our only solution to quantify the quality of the code.  

## How multiple people worked on the same code?
### Protocols
As mentioned above, in general the workload was split by sections (channel, auth, messages, users and miscellaneous) and phases (skeleton code - fundamental functions to complex, standardising data structures, integration to front end and testing).  This however, needed to be regulated by guidelines or protocols to ensure that conflicts are kept to a minimum and the project can be as efficient and neat as possible. Protocols extend from the code style guide that is outlined in the submission and branch naming for the git hub interface. The code style covered the naming conventions for variables, functions and branches. While this fulfils the role of maintaining code readability, it also reduced the ambiguity in naming of global variables which helped in the construction of server information.  

Protocols surrounding git hub included the kebab case of commits.  This maintained commit clarity, showing what exactly was done in the code. The commit protocol included the section that was being worked on, what was being done to it (fixing, adding or removing) and who it was being done by.  Any further details were described after the initials of the person. Having such clear commits allowed members to see exactly what was done and encourages members not to dump hundreds of lines of code at once as it becomes difficult to create concise commit comments.  

There were additional protocols surrounding merges and pushing into master. When merging changes into master, members were required to first pull from master, merge master into their own branch to solve conflicts then submit a merge request on git lab. Then the member is required to notify the group via messenger about the merge request wherein other members can check the code. The system ensured that the code was without conflicts and other members had the opportunity to check the code for bugs within the code. 

### Task Board
As discussed above, the task board was key in distributing work and prioritising functions that needed to be complete at first.  Members were only permitted to work on at most three functions at a time, moving them into the progress list. Once complete the skeleton code and changes to data structures, the code could be moved into the complete list.  The task board was useful in that we could infer where members were struggling and what sections they have completed. This helped struggling members manage expectation and led to more pair programming. 

### Pair Programming/ Code review
Pair programming was key in the fluidity of the group assessment, in the case of members not knowing how data structures were created, not spotting errors in code and not knowing how functions worked, pair programming reduced the time required to solve issues.  This allowed members to both understand their own section and broaden their perspective of the entire project which led to better integration of the whole project.  

